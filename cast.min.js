"use strict";

/* Adding the script tag to the head as suggested before */

var head = document.getElementsByTagName("head")[0];
var script = document.createElement("script");
script.type = "text/javascript";
script.src = "https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js";

// Then bind the event to the callback function.
// There are several events for cross browser compatibility.
script.onreadystatechange = handler;
script.onload = handler;

// Fire the loading
head.appendChild(script);

function handler() {
  $pdk.bind({
    id: "player",
    controls: "full",
    logLevel: "event",
  });

  var added = false;

  /**
   * addCastButton() function to add cast button to Player.
   */
  function addCastButton() {
    var custom = document.createElement("div");
    custom.id = "cast-container";

    var buttonContainer = document.createElement("div");
    buttonContainer.id = "button-container";

    buttonContainer.innerHTML = `<google-cast-launcher id="castbutton"></google-cast-launcher>`;

    custom.appendChild(buttonContainer);

    if (added) return;

    // insert custom button right before fullscreen
    // or at the end of the last row if there's no fullscreen
    var fullscreen = Array.prototype.slice
      .call(
        document.querySelectorAll(".tpPlayer .tpControls .tpRow .tpFullscreen")
      )
      .pop();
    var row;

    // if there is a FS button...
    if (fullscreen) {
      // look for a row in it's parent hierarchy
      row = fullscreen;
      while (
        !row.classList.contains("tpRow") &&
        !row.classList.contains("tpControls")
      ) {
        row = row.parentNode;
      }

      // if we found a row above the FS button...
      if (row.classList.contains("tpRow")) {
        // then insert our custom button into that row
        row.insertBefore(custom, fullscreen);
        added = true;
      }
    } else {
      // otherwise, just get the last row
      row = Array.prototype.slice
        .call(document.querySelectorAll(".tpPlayer .tpControls .tpRow"))
        .pop();
      // and append it
      if (row) {
        row.appendChild(custom);
        added = true;
      }
    }
    // ideally insert before fullscreen
    var fullscreen;
    if (row) {
      fullscreen = row.querySelectorAll(".tpFullscreen");
    }
  }

  /**
   * Card presenter
   */
  function presenter(element, controller) {
    var object = {};
    object.controller = controller;
    object.element = element;
    object.show = function (vars) {
      this.vars = vars;
      if (vars.deviceName) {
        this.element.querySelector("#deviceName").textContent = vars.deviceName;
      }
    };
    object.hide = function () {
      console.log("Stop casting!");
    };
    return object;
  }

  /**
   * Generated Card containes player controller.
   */
  $pdk.controller.addPlayerCard(
    "samples",
    "red",
    "<div class='container'><div class='card-container'><h1 style='color: white; margin:auto;font-size:4vw'>Casting to <span id='deviceName'></span></h1><div class='controls'><div style='display:flex;margin-top:3px;margin:auto'><div id='customPlay' class='custom-icon'></div><div id='customPause' class='custom-icon'></div><div style='display:flex'><div id='customMute' class='custom-icon'></div><div id='customVolume' class='custom-icon'></div><input type='range' min='1' max='100' value='0' class='slider' orient='vertical' step='0.1' id='volumeSlider'></div></div><div class='slidecontainer'><input type='range' min='1' max='100' value='0' class='slider' step='0.1' id='myRange'></div><div id='customTime' style='color:white;margin:auto'><p style='margin-bottom:0px;margin-top:0px;font-size:2vw' id='customTimerText'>00:00:00/00:00:00</p></div><div style='margin:auto'><div style='margin-right:25px'><div id='customCast' class='custom-icon'></div></div></div></div>",
    "player",
    null,
    presenter
  );

  /**
   * Fires when the player begins to load new clip,
   * The data payload for this event thpe contains a Clip object
   */
  $pdk.controller.addEventListener("OnMediaLoadStart", function (clip) {
    castPlayer.playingURL = clip.data.URL;
    addCastButton();
  });

  /**
   * Fires three times per second while the current clip is playing.
   */
  $pdk.controller.addEventListener("OnMediaPlaying", function (time) {
    castPlayer.playingTime = time.data.currentTimeAggregate;
  });

  /**
   * Fires when a release URL is requested by the player.
   */
  $pdk.controller.addEventListener("OnReleaseRequested", function (payload) {
    castPlayer.releaseURL = payload.data.releaseURL;
  });

  // Connect events with player controller and remote device.
  $(document).on("click touchstart", "#customPlay", function () {
    var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
    var mediaSession = castSession.getMediaSession();
    if (mediaSession) {
      $(this).hide();
      $("#customPause").show();
      if (castPlayer.remotePlayer.isPaused) {
        castPlayer.remotePlayerController.playOrPause();
      }
    } else {
      castPlayer.castMediaToDevice();
    }
  });

  $(document).on("click touchstart", "#customPause", function () {
    $(this).hide();
    $("#customPlay").show();
    if (!castPlayer.remotePlayer.isPaused) {
      castPlayer.remotePlayerController.playOrPause();
    }
  });

  $(document).on("click touchstart", "#customMute", function () {
    if ($("#volumeSlider").css("display") == "none") {
      $("#volumeSlider").show();
    } else {
      $("#volumeSlider").hide();
    }
  });

  $(document).on("click touchstart", "#customVolume", function () {
    if ($("#volumeSlider").css("display") == "none") {
      $("#volumeSlider").show();
    } else {
      $("#volumeSlider").hide();
    }
  });

  $(document).on("click touchstart", "#customCast", function () {
    var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
    castSession.endSession(true);
  });

  var prevValue = 0;
  // mouse down to check for previous value
  $("#myRange").on("mousedown touchstart", function (e) {
    prevValue = $(this).val();
  });
  // mouse up when the mouse up from the slider with end value
  $("#myRange").on("mouseup touchend", function () {
    var ThisValue = $(this).val();
    if (ThisValue !== prevValue) {
      var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
      var mediaSession = castSession.getMediaSession();
      if (mediaSession) {
        clearInterval(castPlayer.playerTimer);
        var val =
          (ThisValue - $(this).attr("min")) /
          ($(this).attr("max") - $(this).attr("min"));
        var request = new chrome.cast.media.SeekRequest();
        request.currentTime = castPlayer.remotePlayer.duration * val;
        mediaSession.seek(
          request,
          function () {
            castPlayer.playerTimer = setInterval(setTimerText, 1000);
            console.log("Seek completed!");
          },
          function (error) {
            console.log(error);
          }
        );
      } else {
        changeSliderWithStep($("#myRange"), 0);
      }
    }
  });

  /**
   * Change target slider with it's value.
   * @param {docuemtn.Object} target
   * @param {float} value
   */
  function changeSliderWithStep(target, value) {
    target.val(value);
    var val =
      (target.val() - target.attr("min")) /
      (target.attr("max") - target.attr("min"));
    target.css(
      "background",
      "-webkit-gradient(linear, left top, right top, " +
        "color-stop(" +
        0 +
        ", #04b1ff), " +
        "color-stop(" +
        val +
        ", #04b1ff), " +
        "color-stop(" +
        val +
        ", #ffffff)" +
        ")"
    );
  }

  /**
   * Fires when  volumn slider changes.
   */
  function changeVolumeSlider() {
    var val =
      ($(this).val() - $(this).attr("min")) /
      ($(this).attr("max") - $(this).attr("min"));
    $(this).css(
      "background",
      "-webkit-gradient(linear, left top, right top, " +
        "color-stop(" +
        0 +
        ", #04b1ff), " +
        "color-stop(" +
        val +
        ", #04b1ff), " +
        "color-stop(" +
        val +
        ", #ffffff)" +
        ")"
    );
    if (val == 0) {
      $("#customVolume").hide();
      $("#customMute").show();
    } else {
      $("#customMute").hide();
      $("#customVolume").show();
    }
    castPlayer.remotePlayer.volumeLevel = val;
    castPlayer.remotePlayerController.setVolumeLevel();
  }

  /**
   * Fires when progress slider changes.
   */
  function changeSlider() {
    var val =
      ($(this).val() - $(this).attr("min")) /
      ($(this).attr("max") - $(this).attr("min"));
    $(this).css(
      "background",
      "-webkit-gradient(linear, left top, right top, " +
        "color-stop(" +
        0 +
        ", #04b1ff), " +
        "color-stop(" +
        val +
        ", #04b1ff), " +
        "color-stop(" +
        val +
        ", #ffffff)" +
        ")"
    );
  }

  /**
   * return HH:MM:SS from total second.
   * @param {second} second
   */
  function changeSecondtoHMS(second) {
    var date = new Date(null);
    date.setSeconds(second);
    var result = date.toISOString().substr(11, 8);
    return result;
  }

  /**
   * Set Time text and changes progress slider with it's value.
   */
  function setTimerText() {
    var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
    var mediaSession = castSession.getMediaSession();
    if (mediaSession) {
      var currentTime = mediaSession.getEstimatedTime();
      castPlayer.currentCastingTime = currentTime;
      var totalTime = changeSecondtoHMS(castPlayer.remotePlayer.duration);
      var time = changeSecondtoHMS(currentTime);
      $("#customTimerText").text(time + "/" + totalTime);
      var percentage = (currentTime / castPlayer.remotePlayer.duration) * 100;
      changeSliderWithStep($("#myRange"), percentage);
      return;
    }
    clearInterval(castPlayer.playerTimer);
    castPlayer.playingTime = 0;
    castSession.endSession(true);
  }

  // Connect slider change event with it's function.
  $("#myRange").on("input propertychange", changeSlider);
  $("#volumeSlider").on("input propertychange", changeVolumeSlider);

  /**
   * Cast player object
   */
  var CastPlayer = function () {
    /* Cast player variables */
    /** @type {cast.framework.RemotePlayer} */
    this.remotePlayer = null;
    /** @type {cast.framework.RemotePlayerController} */
    this.remotePlayerController = null;

    /* Local video playing status */
    this.playingURL = null;
    this.playingTime = null;
    this.playerTimer = null;
    this.releaseURL = null;
    this.isNewMediaLoaded = false;
    this.currentCastingTime = null;
  };

  /**
   * Initialize the cast framework and set remotePlayer and remotePlayerController.
   */
  CastPlayer.prototype.initializeCastPlayer = function () {
    var options = {};

    // Set the receiver application ID to your own (created in the
    // Google Cast Developer Console), or optionally
    // use the chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID
    options.receiverApplicationId =
      chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID;

    // Auto join policy can be one of the following three:
    // ORIGIN_SCOPED - Auto connect from same appId and page origin
    // TAB_AND_ORIGIN_SCOPED - Auto connect from same appId, page origin, and tab
    // PAGE_SCOPED - No auto connect
    options.autoJoinPolicy = chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED;

    cast.framework.CastContext.getInstance().setOptions(options);

    this.remotePlayer = new cast.framework.RemotePlayer();
    this.remotePlayerController = new cast.framework.RemotePlayerController(
      this.remotePlayer
    );
    this.remotePlayerController.addEventListener(
      cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED,
      this.switchPlayer.bind(this)
    );
  };

  /**
   * Switch to remote Player if device exists.
   */
  CastPlayer.prototype.switchPlayer = function () {
    if (cast && cast.framework) {
      if (this.remotePlayer.isConnected) {
        this.setupRemotePlayer();
        return;
      }
    }
    this.setupLocalPlayer();
  };

  /**
   * Set up remote Player
   */
  CastPlayer.prototype.setupRemotePlayer = function () {
    this.castMediaToDevice();
  };

  /**
   * Set up local Player
   */
  CastPlayer.prototype.setupLocalPlayer = function () {
    // if (!castPlayer.remotePlayer.savedPlayerState.mediaInfo) {
    //   $pdk.controller.preview(castPlayer.releaseURL);
    // } else {
    //   $pdk.controller.seekTo(castPlayer.currentCastingTime * 1000);
    //   $pdk.controller.pause(false);
    // }
    $pdk.controller.hidePlayerCard("samples", "red");
    clearInterval(castPlayer.playerTimer);
  };

  /**
   * Load Media to device.
   */
  CastPlayer.prototype.castMediaToDevice = function () {
    /**
     * To get the current connected session.
     */
    var castSession = cast.framework.CastContext.getInstance().getCurrentSession();

    /**
     * mediaInfo to set the sending data from sender app to receiver device.
     */
    if (castPlayer.playingURL) {
      var mediaInfo = new chrome.cast.media.MediaInfo(castPlayer.playingURL);
      mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
      mediaInfo.metadata.metadataType = chrome.cast.media.MetadataType.GENERIC;
      var request = new chrome.cast.media.LoadRequest(mediaInfo);
      castSession.loadMedia(request).then(
        function () {
          // Stop current playing media in loacal device.
          // $pdk.controller.pause(true);
          $pdk.controller.mute();
          // 50% current playing media in remote device.
          castPlayer.remotePlayer.volumeLevel = 0.5;
          castPlayer.remotePlayerController.setVolumeLevel();
          // Initialize the display of card.
          $("#customPlay").hide();
          $("#customPause").show();
          $("#customMute").show();
          $("#customVolume").hide();
          $("#volumeSlider").hide();
          changeSliderWithStep($("#volumeSlider"), 1);
          // Show card with controls.
          $pdk.controller.showPlayerCard("samples", "red", null, {
            deviceName: castSession.getCastDevice().friendlyName,
          });

          // Set timer for progress
          castPlayer.playerTimer = setInterval(setTimerText, 1000);

          // seek to currenttime of local player.
          // var mediaSession = castSession.getMediaSession();
          // var request = new chrome.cast.media.SeekRequest();
          // request.currentTime = castPlayer.playingTime / 1000;
          // mediaSession.seek(
          //   request,
          //   function () {
          //     console.log("Seek completed!");
          //   },
          //   function (error) {
          //     console.log(error);
          //   }
          // );
        },
        function (errorCode) {
          console.log(
            "Remote media load error: " + CastPlayer.getErrorMessage(errorCode)
          );
        }
      );
    }
  };

  /**
   * Makes human-readable message from chrome.cast.Error
   * @param {chrome.cast.Error} error
   * @return {string} error message
   */
  CastPlayer.getErrorMessage = function (error) {
    switch (error.code) {
      case chrome.cast.ErrorCode.API_NOT_INITIALIZED:
        return (
          "The API is not initialized." +
          (error.description ? " :" + error.description : "")
        );
      case chrome.cast.ErrorCode.CANCEL:
        return (
          "The operation was canceled by the user" +
          (error.description ? " :" + error.description : "")
        );
      case chrome.cast.ErrorCode.CHANNEL_ERROR:
        return (
          "A channel to the receiver is not available." +
          (error.description ? " :" + error.description : "")
        );
      case chrome.cast.ErrorCode.EXTENSION_MISSING:
        return (
          "The Cast extension is not available." +
          (error.description ? " :" + error.description : "")
        );
      case chrome.cast.ErrorCode.INVALID_PARAMETER:
        return (
          "The parameters to the operation were not valid." +
          (error.description ? " :" + error.description : "")
        );
      case chrome.cast.ErrorCode.RECEIVER_UNAVAILABLE:
        return (
          "No receiver was compatible with the session request." +
          (error.description ? " :" + error.description : "")
        );
      case chrome.cast.ErrorCode.SESSION_ERROR:
        return (
          "A session could not be created, or a session was invalid." +
          (error.description ? " :" + error.description : "")
        );
      case chrome.cast.ErrorCode.TIMEOUT:
        return (
          "The operation timed out." +
          (error.description ? " :" + error.description : "")
        );
    }
  };

  /**
   * Make the instance of Cast Player and initialize.
   */
  var castPlayer = new CastPlayer();
  window["__onGCastApiAvailable"] = function (isAvailable) {
    if (isAvailable) {
      castPlayer.initializeCastPlayer();
    }
  };

  // Call the cast framework javascript and inset it to body.
  var script = document.createElement("script");
  script.setAttribute("type", "text/javascript");
  script.src =
    "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1";
  document.body.appendChild(script);
}
